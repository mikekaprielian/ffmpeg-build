--- ffmpeg-build-static-sources/FFmpeg/doc/muxers.texi	2022-12-29 13:49:11.230996181 +0000
+++ ffmpeg-build-static-sources/FFmpeg/doc/muxers.texi	2022-12-29 14:17:51.292623817 +0000
@@ -2300,6 +2302,11 @@
 
 @item live
 Allow live-friendly file generation.
+
+@item delete
+Segment files removed from the playlist are deleted after a period of time
+equal to the duration of the segment plus the duration of the playlist.
+
 @end table
 
 @item segment_list_size @var{size}

--- ffmpeg-build-static-sources/FFmpeg/libavformat/segment.c	2023-03-13 17:36:09.000000000 +0000
+++ ffmpeg-build-static-sources/FFmpeg/libavformat/segment.c	2023-03-13 17:42:45.704760889 +0000
@@ -25,10 +25,15 @@
  */
 
 #include "config_components.h"
-
+#include "config.h"
+#include <float.h>
 #include <time.h>
+#if HAVE_UNISTD_H
+#include <unistd.h>
+#endif
 
 #include "avformat.h"
+#include "avio_internal.h"
 #include "internal.h"
 #include "mux.h"
 
@@ -66,6 +71,7 @@
 
 #define SEGMENT_LIST_FLAG_CACHE 1
 #define SEGMENT_LIST_FLAG_LIVE  2
+#define SEGMENT_LIST_FLAG_DELETE 4
 
 typedef struct SegmentContext {
     const AVClass *class;  /**< Class for private options. */
@@ -93,7 +99,6 @@
     int list_type;         ///< set the list type
     AVIOContext *list_pb;  ///< list file put-byte context
     int64_t time;          ///< segment duration
-    int64_t min_seg_duration;  ///< minimum segment duration
     int use_strftime;      ///< flag to expand filename with strftime
     int increment_tc;      ///< flag to increment timecode if found
 
@@ -116,7 +121,6 @@
     int64_t initial_offset;    ///< initial timestamps offset, expressed in microseconds
     char *reference_stream_specifier; ///< reference stream specifier
     int   reference_stream_index;
-    int64_t reference_stream_first_pts;    ///< initial timestamp, expressed in microseconds
     int   break_non_keyframes;
     int   write_empty;
 
@@ -126,6 +130,7 @@
     SegmentListEntry cur_entry;
     SegmentListEntry *segment_list_entries;
     SegmentListEntry *segment_list_entries_end;
+    SegmentListEntry *segment_list_old;
 } SegmentContext;
 
 static void print_csv_escaped_str(AVIOContext *ctx, const char *str)
@@ -144,6 +149,65 @@
         avio_w8(ctx, '"');
 }
 
+static int delete_old_segments(SegmentContext *seg)
+{
+    SegmentListEntry *segment, *previous_segment = NULL;
+    float playlist_duration = 0.0f;
+    int ret = 0, path_size;
+    char *dirname = NULL, *p;
+    char *path = NULL;
+    segment = seg->segment_list_entries;
+    while (segment) {
+        playlist_duration += segment->end_time - segment->start_time;
+        segment = segment->next;
+    }
+    segment = seg->segment_list_old;
+    while (segment) {
+        playlist_duration -= segment->end_time - segment->start_time;
+        previous_segment = segment;
+        segment = previous_segment->next;
+        if (playlist_duration <= -(previous_segment->end_time - previous_segment->start_time)) {
+            previous_segment->next = NULL;
+            break;
+        }
+    }
+    if (segment) {
+        dirname = av_strdup(seg->avf->url);
+        if (!dirname) {
+            ret = AVERROR(ENOMEM);
+            goto fail;
+        }
+        p = (char *)av_basename(dirname);
+        *p = '\0';
+    }
+    while (segment) {
+        av_log(seg, AV_LOG_DEBUG, "deleting old segment %s\n",
+                                  segment->filename);
+        path_size = strlen(dirname) + strlen(segment->filename) + 1;
+        path = av_malloc(path_size);
+        if (!path) {
+            ret = AVERROR(ENOMEM);
+            goto fail;
+        }
+        av_strlcpy(path, dirname, path_size);
+        av_strlcat(path, segment->filename, path_size);
+        if (unlink(path) < 0) {
+            av_log(segment, AV_LOG_ERROR, "failed to delete old segment %s: %s\n",
+                                          path, strerror(errno));
+        }
+        av_freep(&path);
+        previous_segment = segment;
+        segment = previous_segment->next;
+        av_freep(&previous_segment->filename);
+        av_free(previous_segment);
+    }
+fail:
+    av_free(path);
+    av_free(dirname);
+    return ret;
+}
+
+
 static int segment_mux_init(AVFormatContext *s)
 {
     SegmentContext *seg = s->priv_data;
@@ -160,11 +224,7 @@
     oc->max_delay          = s->max_delay;
     av_dict_copy(&oc->metadata, s->metadata, 0);
     oc->opaque             = s->opaque;
-#if FF_API_AVFORMAT_IO_CLOSE
-FF_DISABLE_DEPRECATION_WARNINGS
     oc->io_close           = s->io_close;
-FF_ENABLE_DEPRECATION_WARNINGS
-#endif
     oc->io_close2          = s->io_close2;
     oc->io_open            = s->io_open;
     oc->flags              = s->flags;
@@ -173,9 +233,12 @@
         AVStream *st, *ist = s->streams[i];
         AVCodecParameters *ipar = ist->codecpar, *opar;
 
-        st = ff_stream_clone(oc, ist);
-        if (!st)
+        if (!(st = avformat_new_stream(oc, NULL)))
             return AVERROR(ENOMEM);
+        ret = ff_stream_encode_params_copy(st, ist);
+        if (ret < 0)
+            return ret;
         opar = st->codecpar;
         if (!oc->oformat->codec_tag ||
             av_codec_get_id (oc->oformat->codec_tag, ipar->codec_tag) == opar->codec_id ||
@@ -392,8 +455,16 @@
             if (seg->list_size && seg->segment_count >= seg->list_size) {
                 entry = seg->segment_list_entries;
                 seg->segment_list_entries = seg->segment_list_entries->next;
+                if (entry && seg->list_flags & SEGMENT_LIST_FLAG_DELETE &&
+                        !seg->segment_idx_wrap) {
+                    entry->next = seg->segment_list_old;
+                    seg->segment_list_old = entry;
+                    if ((ret = delete_old_segments(seg)) < 0)
+                        return ret;
+                } else {
                 av_freep(&entry->filename);
                 av_freep(&entry);
+              }
             }
 
             if ((ret = segment_list_open(s)) < 0)
@@ -702,9 +773,6 @@
         return AVERROR(EINVAL);
     }
 
-    if (seg->times_str || seg->frames_str)
-        seg->min_seg_duration = 0;
-
     if (seg->times_str) {
         if ((ret = parse_times(s, &seg->times, &seg->nb_times, seg->times_str)) < 0)
             return ret;
@@ -719,10 +787,6 @@
             }
             seg->clocktime_offset = seg->time - (seg->clocktime_offset % seg->time);
         }
-        if (seg->min_seg_duration > seg->time) {
-            av_log(s, AV_LOG_ERROR, "min_seg_duration cannot be greater than segment_time\n");
-            return AVERROR(EINVAL);
-        }
     }
 
     if (seg->list) {
@@ -751,8 +815,6 @@
            seg->reference_stream_index,
            av_get_media_type_string(s->streams[seg->reference_stream_index]->codecpar->codec_type));
 
-    seg->reference_stream_first_pts = AV_NOPTS_VALUE;
-
     seg->oformat = av_guess_format(seg->format, s->url, NULL);
 
     if (!seg->oformat)
@@ -854,7 +916,7 @@
 {
     SegmentContext *seg = s->priv_data;
     AVStream *st = s->streams[pkt->stream_index];
-    int64_t end_pts = INT64_MAX, offset, pkt_pts_avtb;
+    int64_t end_pts = INT64_MAX, offset;
     int start_frame = INT_MAX;
     int ret;
     struct tm ti;
@@ -905,27 +967,11 @@
             pkt->flags & AV_PKT_FLAG_KEY,
             pkt->stream_index == seg->reference_stream_index ? seg->frame_count : -1);
 
-    if (seg->reference_stream_first_pts == AV_NOPTS_VALUE &&
-        pkt->stream_index == seg->reference_stream_index &&
-        pkt->pts != AV_NOPTS_VALUE) {
-        seg->reference_stream_first_pts = av_rescale_q(pkt->pts, st->time_base, AV_TIME_BASE_Q);
-    }
-
-    if (seg->reference_stream_first_pts != AV_NOPTS_VALUE) {
-        end_pts += (INT64_MAX - end_pts >= seg->reference_stream_first_pts) ?
-                    seg->reference_stream_first_pts :
-                    INT64_MAX - end_pts;
-    }
-
-    if (pkt->pts != AV_NOPTS_VALUE)
-        pkt_pts_avtb = av_rescale_q(pkt->pts, st->time_base, AV_TIME_BASE_Q);
-
     if (pkt->stream_index == seg->reference_stream_index &&
         (pkt->flags & AV_PKT_FLAG_KEY || seg->break_non_keyframes) &&
         (seg->segment_frame_count > 0 || seg->write_empty) &&
         (seg->cut_pending || seg->frame_count >= start_frame ||
          (pkt->pts != AV_NOPTS_VALUE &&
-          pkt_pts_avtb - seg->cur_entry.start_pts >= seg->min_seg_duration &&
           av_compare_ts(pkt->pts, st->time_base,
                         end_pts - seg->time_delta, AV_TIME_BASE_Q) >= 0))) {
         /* sanitize end time in case last packet didn't have a defined duration */
@@ -981,7 +1027,7 @@
 
     ret = ff_write_chained(seg->avf, pkt->stream_index, pkt, s,
-                           seg->initial_offset || seg->reset_timestamps ||
-                           ffofmt(seg->avf->oformat)->interleave_packet);
+                           seg->initial_offset || seg->reset_timestamps || seg->avf->oformat->interleave_packet);
 
 fail:
     /* Use st->index here as the packet returned from ff_write_chained()
@@ -998,22 +1044,55 @@
 {
     SegmentContext *seg = s->priv_data;
     AVFormatContext *oc = seg->avf;
+    SegmentListEntry *cur, *next;
     int ret;
 
-    if (!oc)
-        return 0;
+    if (!oc) {
+        goto fail;
+      }
-
     if (!seg->write_header_trailer) {
         if ((ret = segment_end(s, 0, 1)) < 0)
-            return ret;
+            goto fail;
         if ((ret = open_null_ctx(&oc->pb)) < 0)
-            return ret;
+            goto fail;
         seg->is_nullctx = 1;
         ret = av_write_trailer(oc);
     } else {
         ret = segment_end(s, 1, 1);
     }
+fail:
+    if (seg->list)
+        ff_format_io_close(s, &seg->list_pb);
+
+    av_dict_free(&seg->format_options);
+    av_opt_free(seg);
+    av_freep(&seg->times);
+    av_freep(&seg->frames);
+    av_freep(&seg->cur_entry.filename);
+
+    cur = seg -> segment_list_entries;
+    while (cur) {
+        next = cur->next;
+        av_freep(&cur->filename);
+        av_free(cur);
+        cur = next;
+    }
+
+    cur = seg->segment_list_old;
+    while (cur) {
+        next = cur->next;
+        av_freep(&cur->filename);
+        av_free(cur);
+        cur = next;
+    }
+
+
+    avformat_free_context(oc);
+    seg->avf = NULL;
+
     return ret;
+
 }
 
 static int seg_check_bitstream(AVFormatContext *s, AVStream *st,
@@ -1021,8 +1100,9 @@
 {
     SegmentContext *seg = s->priv_data;
     AVFormatContext *oc = seg->avf;
-    if (ffofmt(oc->oformat)->check_bitstream) {
+    if (oc->oformat->check_bitstream) {
         AVStream *const ost = oc->streams[st->index];
+        int ret = oc->oformat->check_bitstream(oc, ost, pkt);
-        int ret = ffofmt(oc->oformat)->check_bitstream(oc, ost, pkt);
         if (ret == 1) {
             FFStream *const  sti = ffstream(st);
@@ -1047,6 +1127,7 @@
     { "segment_list_flags","set flags affecting segment list generation", OFFSET(list_flags), AV_OPT_TYPE_FLAGS, {.i64 = SEGMENT_LIST_FLAG_CACHE }, 0, UINT_MAX, E, "list_flags"},
     { "cache",             "allow list caching",                                    0, AV_OPT_TYPE_CONST, {.i64 = SEGMENT_LIST_FLAG_CACHE }, INT_MIN, INT_MAX,   E, "list_flags"},
     { "live",              "enable live-friendly list generation (useful for HLS)", 0, AV_OPT_TYPE_CONST, {.i64 = SEGMENT_LIST_FLAG_LIVE }, INT_MIN, INT_MAX,    E, "list_flags"},
+    { "delete",            "delete segment files that are no longer part of the playlist", 0, AV_OPT_TYPE_CONST, {.i64 = SEGMENT_LIST_FLAG_DELETE }, INT_MIN, INT_MAX,    E, "list_flags"},
 
     { "segment_list_size", "set the maximum number of playlist entries", OFFSET(list_size), AV_OPT_TYPE_INT,  {.i64 = 0},     0, INT_MAX, E },
 
@@ -1090,33 +1171,33 @@
 };
 
 #if CONFIG_SEGMENT_MUXER
-const FFOutputFormat ff_segment_muxer = {
-    .p.name          = "segment",
-    .p.long_name     = NULL_IF_CONFIG_SMALL("segment"),
-    .p.flags         = AVFMT_NOFILE|AVFMT_GLOBALHEADER,
-    .p.priv_class    = &seg_class,
+const AVOutputFormat ff_segment_muxer = {
+    .name           = "segment",
+    .long_name      = NULL_IF_CONFIG_SMALL("segment"),
     .priv_data_size = sizeof(SegmentContext),
+    .flags          = AVFMT_NOFILE|AVFMT_GLOBALHEADER,
     .init           = seg_init,
     .write_header   = seg_write_header,
     .write_packet   = seg_write_packet,
     .write_trailer  = seg_write_trailer,
     .deinit         = seg_free,
     .check_bitstream = seg_check_bitstream,
+    .priv_class     = &seg_class,
 };
 #endif
 
 #if CONFIG_STREAM_SEGMENT_MUXER
-const FFOutputFormat ff_stream_segment_muxer = {
-    .p.name          = "stream_segment,ssegment",
-    .p.long_name     = NULL_IF_CONFIG_SMALL("streaming segment muxer"),
-    .p.flags         = AVFMT_NOFILE,
-    .p.priv_class    = &seg_class,
-    .priv_data_size  = sizeof(SegmentContext),
+const AVOutputFormat ff_stream_segment_muxer = {
+    .name           = "stream_segment,ssegment",
+    .long_name      = NULL_IF_CONFIG_SMALL("streaming segment muxer"),
+    .priv_data_size = sizeof(SegmentContext),
+    .flags          = AVFMT_NOFILE,
     .init           = seg_init,
     .write_header   = seg_write_header,
     .write_packet   = seg_write_packet,
     .write_trailer  = seg_write_trailer,
     .deinit         = seg_free,
     .check_bitstream = seg_check_bitstream,
+    .priv_class     = &seg_class,
 };
 #endif
