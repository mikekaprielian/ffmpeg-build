--- ffmpeg-build-static-sources/FFmpeg/doc/muxers.texi	2022-12-29 13:49:11.230996181 +0000
+++ ffmpeg-build-static-sources/FFmpeg/doc/muxers.texi	2022-12-29 14:17:51.292623817 +0000
@@ -2304,6 +2306,11 @@
 
 @item live
 Allow live-friendly file generation.
+
+@item delete
+Segment files removed from the playlist are deleted after a period of time
+equal to the duration of the segment plus the duration of the playlist.
+
 @end table
 
 @item segment_list_size @var{size}

--- ffmpeg-build-static-sources/FFmpeg/libavformat/segment.c	2023-03-13 17:36:09.000000000 +0000
+++ ffmpeg-build-static-sources/FFmpeg/libavformat/segment.c	2023-03-13 17:42:45.704760889 +0000
@@ -25,10 +25,15 @@
  */
 
 #include "config_components.h"
-
+#include "config.h"
+#include <float.h>
 #include <time.h>
+#if HAVE_UNISTD_H
+#include <unistd.h>
+#endif
 
 #include "avformat.h"
+#include "avio_internal.h"
 #include "internal.h"
 #include "mux.h"
 
@@ -66,6 +71,7 @@
 
 #define SEGMENT_LIST_FLAG_CACHE 1
 #define SEGMENT_LIST_FLAG_LIVE  2
+#define SEGMENT_LIST_FLAG_DELETE 4
 
 typedef struct SegmentContext {
     const AVClass *class;  /**< Class for private options. */
@@ -124,6 +130,7 @@
     SegmentListEntry cur_entry;
     SegmentListEntry *segment_list_entries;
     SegmentListEntry *segment_list_entries_end;
+    SegmentListEntry *segment_list_old;
 } SegmentContext;
 
 static void print_csv_escaped_str(AVIOContext *ctx, const char *str)
@@ -142,6 +149,65 @@
         avio_w8(ctx, '"');
 }
 
+static int delete_old_segments(SegmentContext *seg)
+{
+    SegmentListEntry *segment, *previous_segment = NULL;
+    float playlist_duration = 0.0f;
+    int ret = 0, path_size;
+    char *dirname = NULL, *p;
+    char *path = NULL;
+    segment = seg->segment_list_entries;
+    while (segment) {
+        playlist_duration += segment->end_time - segment->start_time;
+        segment = segment->next;
+    }
+    segment = seg->segment_list_old;
+    while (segment) {
+        playlist_duration -= segment->end_time - segment->start_time;
+        previous_segment = segment;
+        segment = previous_segment->next;
+        if (playlist_duration <= -(previous_segment->end_time - previous_segment->start_time)) {
+            previous_segment->next = NULL;
+            break;
+        }
+    }
+    if (segment) {
+        dirname = av_strdup(seg->avf->url);
+        if (!dirname) {
+            ret = AVERROR(ENOMEM);
+            goto fail;
+        }
+        p = (char *)av_basename(dirname);
+        *p = '\0';
+    }
+    while (segment) {
+        av_log(seg, AV_LOG_DEBUG, "deleting old segment %s\n",
+                                  segment->filename);
+        path_size = strlen(dirname) + strlen(segment->filename) + 1;
+        path = av_malloc(path_size);
+        if (!path) {
+            ret = AVERROR(ENOMEM);
+            goto fail;
+        }
+        av_strlcpy(path, dirname, path_size);
+        av_strlcat(path, segment->filename, path_size);
+        if (unlink(path) < 0) {
+            av_log(segment, AV_LOG_ERROR, "failed to delete old segment %s: %s\n",
+                                          path, strerror(errno));
+        }
+        av_freep(&path);
+        previous_segment = segment;
+        segment = previous_segment->next;
+        av_freep(&previous_segment->filename);
+        av_free(previous_segment);
+    }
+fail:
+    av_free(path);
+    av_free(dirname);
+    return ret;
+}
+
+
 static int segment_mux_init(AVFormatContext *s)
 {
     SegmentContext *seg = s->priv_data;
@@ -388,8 +454,16 @@
             if (seg->list_size && seg->segment_count >= seg->list_size) {
                 entry = seg->segment_list_entries;
                 seg->segment_list_entries = seg->segment_list_entries->next;
+                if (entry && seg->list_flags & SEGMENT_LIST_FLAG_DELETE &&
+                        !seg->segment_idx_wrap) {
+                    entry->next = seg->segment_list_old;
+                    seg->segment_list_old = entry;
+                    if ((ret = delete_old_segments(seg)) < 0)
+                        return ret;
+                } else {
                 av_freep(&entry->filename);
                 av_freep(&entry);
+              }
             }
 
             if ((ret = segment_list_open(s)) < 0)
@@ -968,22 +1042,54 @@
 {
     SegmentContext *seg = s->priv_data;
     AVFormatContext *oc = seg->avf;
+    SegmentListEntry *cur, *next;
     int ret;
 
-    if (!oc)
-        return 0;
-
+    if (!oc) {
+        goto fail;
+      }
     if (!seg->write_header_trailer) {
         if ((ret = segment_end(s, 0, 1)) < 0)
-            return ret;
+            goto fail;
         if ((ret = open_null_ctx(&oc->pb)) < 0)
-            return ret;
+            goto fail;
         seg->is_nullctx = 1;
         ret = av_write_trailer(oc);
     } else {
         ret = segment_end(s, 1, 1);
     }
+fail:
+    if (seg->list)
+        ff_format_io_close(s, &seg->list_pb);
+
+    av_dict_free(&seg->format_options);
+    av_opt_free(seg);
+    av_freep(&seg->times);
+    av_freep(&seg->frames);
+    av_freep(&seg->cur_entry.filename);
+
+    cur = seg -> segment_list_entries;
+    while (cur) {
+        next = cur->next;
+        av_freep(&cur->filename);
+        av_free(cur);
+        cur = next;
+    }
+
+    cur = seg->segment_list_old;
+    while (cur) {
+        next = cur->next;
+        av_freep(&cur->filename);
+        av_free(cur);
+        cur = next;
+    }
+
+
+    avformat_free_context(oc);
+    seg->avf = NULL;
+
     return ret;
+
 }
 
 static int seg_check_bitstream(AVFormatContext *s, AVStream *st,
@@ -1017,6 +1123,7 @@
     { "segment_list_flags","set flags affecting segment list generation", OFFSET(list_flags), AV_OPT_TYPE_FLAGS, {.i64 = SEGMENT_LIST_FLAG_CACHE }, 0, UINT_MAX, E, "list_flags"},
     { "cache",             "allow list caching",                                    0, AV_OPT_TYPE_CONST, {.i64 = SEGMENT_LIST_FLAG_CACHE }, INT_MIN, INT_MAX,   E, "list_flags"},
     { "live",              "enable live-friendly list generation (useful for HLS)", 0, AV_OPT_TYPE_CONST, {.i64 = SEGMENT_LIST_FLAG_LIVE }, INT_MIN, INT_MAX,    E, "list_flags"},
+    { "delete",            "delete segment files that are no longer part of the playlist", 0, AV_OPT_TYPE_CONST, {.i64 = SEGMENT_LIST_FLAG_DELETE }, INT_MIN, INT_MAX,    E, "list_flags"},
 
     { "segment_list_size", "set the maximum number of playlist entries", OFFSET(list_size), AV_OPT_TYPE_INT,  {.i64 = 0},     0, INT_MAX, E },
 



--- ffmpeg-build-static-sources/FFmpeg/fftools/ffmpeg.c	2023-05-04 11:31:02.390518574 +0000
+++ ffmpeg-build-static-sources/FFmpeg/fftools/ffmpeg.c	2023-05-04 12:09:14.946814417 +0000
@@ -1694,15 +1694,25 @@
     }
     av_bprint_finalize(&buf, NULL);
 
-    if (progress_avio) {
+    should_print = should_print ? 0 : 1;
+    if (progress_filename && should_print && ((cur_time - timer_start) / 1000000) % 30 == 0)
+    {
+        AVIOContext *avio = NULL;
+        ret = avio_open2(&avio, progress_filename, AVIO_FLAG_WRITE, &int_cb, NULL);
+        if (ret < 0)
+        {
+            av_log(NULL, AV_LOG_ERROR, "Failed to open progress URL \"%s\": %s\n",
+                   progress_filename, av_err2str(ret));
+            return;
+        }
         av_bprintf(&buf_script, "progress=%s\n",
                    is_last_report ? "end" : "continue");
-        avio_write(progress_avio, buf_script.str,
+        avio_write(avio, buf_script.str,
                    FFMIN(buf_script.len, buf_script.size - 1));
-        avio_flush(progress_avio);
+        avio_flush(_avio);
         av_bprint_finalize(&buf_script, NULL);
         if (is_last_report) {
-            if ((ret = avio_closep(&progress_avio)) < 0)
+            if ((ret = avio_closep(&avio)) < 0)
                 av_log(NULL, AV_LOG_ERROR,
                        "Error closing progress log, loss of information possible: %s\n", av_err2str(ret));
         }

 
--- ffmpeg-build-static-sources/FFmpeg/fftools/ffmpeg_mux.c	2023-05-04 12:00:39.065724122 +0000
+++ ffmpeg-build-static-sources/FFmpeg/fftools/ffmpeg_mux.c	2023-05-04 12:01:24.633444750 +0000
@@ -111,7 +111,7 @@
 
     av_packet_rescale_ts(pkt, ost->mux_timebase, ost->st->time_base);
 
-    if (!(s->oformat->flags & AVFMT_NOTIMESTAMPS)) {
+    if (fix_dts && !(s->oformat->flags & AVFMT_NOTIMESTAMPS)) {
         if (pkt->dts != AV_NOPTS_VALUE &&
             pkt->pts != AV_NOPTS_VALUE &&
             pkt->dts > pkt->pts) {
             
             
--- ffmpeg-build-static-sources/FFmpeg/fftools/ffmpeg.h	2023-05-04 12:15:09.541009606 +0000
+++ ffmpeg-build-static-sources/FFmpeg/fftools/ffmpeg.h	2023-05-04 12:15:30.724904464 +0000
@@ -620,6 +620,8 @@
 extern float dts_delta_threshold;
 extern float dts_error_threshold;
 
+extern char *progress_filename;
+extern int fix_dts;
 extern int audio_volume;
 extern int audio_sync_method;
 extern enum VideoSyncMethod video_sync_method;
@@ -640,7 +642,6 @@
 extern int qp_hist;
 extern int stdin_interaction;
 extern int frame_bits_per_raw_sample;
-extern AVIOContext *progress_avio;
 extern float max_error_rate;
 
 extern char *filter_nbthreads;

--- ffmpeg-build-static-sources/FFmpeg/fftools/ffmpeg_opt.c	2023-05-04 12:54:51.033674863 +0000
+++ ffmpeg-build-static-sources/FFmpeg/fftools/ffmpeg_opt.c	2023-05-04 12:56:52.000963412 +0000
@@ -152,6 +152,7 @@
 char *vstats_filename;
 char *sdp_filename;
 
+char *progress_filename;
 float audio_drift_threshold = 0.1;
 float dts_delta_threshold   = 10;
 float dts_error_threshold   = 3600*30;
@@ -162,6 +163,7 @@
 float frame_drop_threshold = 0;
 int do_benchmark      = 0;
 int do_benchmark_all  = 0;
+int fix_dts           = 1;
 int do_hex_dump       = 0;
 int do_pkt_dump       = 0;
 int copy_ts           = 0;
@@ -3615,18 +3617,7 @@
 
 static int opt_progress(void *optctx, const char *opt, const char *arg)
 {
-    AVIOContext *avio = NULL;
-    int ret;
-
-    if (!strcmp(arg, "-"))
-        arg = "pipe:";
-    ret = avio_open2(&avio, arg, AVIO_FLAG_WRITE, &int_cb, NULL);
-    if (ret < 0) {
-        av_log(NULL, AV_LOG_ERROR, "Failed to open progress URL \"%s\": %s\n",
-               arg, av_err2str(ret));
-        return ret;
-    }
-    progress_avio = avio;
+ progress_filename = arg;
     return 0;
 }
 
@@ -3753,6 +3744,8 @@
         "audio drift threshold", "threshold" },
     { "copyts",         OPT_BOOL | OPT_EXPERT,                       { &copy_ts },
         "copy timestamps" },
+    { "fix_dts",        OPT_BOOL | OPT_EXPERT,                       { &fix_dts },
+        "fix invalid dts" },
     { "start_at_zero",  OPT_BOOL | OPT_EXPERT,                       { &start_at_zero },
         "shift input timestamps to start at 0 when using copyts" },
     { "copytb",         HAS_ARG | OPT_INT | OPT_EXPERT,              { &copy_tb },


--- ffmpeg-build-static-sources/FFmpeg/libavformat/mpegtsenc.c	2023-03-14 01:36:50.899247554 +0000
+++ ffmpeg-build-static-sources/FFmpeg/libavformat/mpegtsenc.c	2023-05-04 12:23:00.486714302 +0000
@@ -1750,33 +1750,11 @@
 
 int ff_check_h264_startcode(AVFormatContext *s, const AVStream *st, const AVPacket *pkt)
 {
-    if (pkt->size < 5 || AV_RB32(pkt->data) != 0x0000001 && AV_RB24(pkt->data) != 0x000001) {
-        if (!st->nb_frames) {
-            av_log(s, AV_LOG_ERROR, "H.264 bitstream malformed, "
-                   "no startcode found, use the video bitstream filter 'h264_mp4toannexb' to fix it "
-                   "('-bsf:v h264_mp4toannexb' option with ffmpeg)\n");
-            return AVERROR_INVALIDDATA;
-        }
-        av_log(s, AV_LOG_WARNING, "H.264 bitstream error, startcode missing, size %d", pkt->size);
-        if (pkt->size)
-            av_log(s, AV_LOG_WARNING, " data %08"PRIX32, AV_RB32(pkt->data));
-        av_log(s, AV_LOG_WARNING, "\n");
-    }
     return 0;
 }
 
 static int check_hevc_startcode(AVFormatContext *s, const AVStream *st, const AVPacket *pkt)
 {
-    if (pkt->size < 5 || AV_RB32(pkt->data) != 0x0000001 && AV_RB24(pkt->data) != 0x000001) {
-        if (!st->nb_frames) {
-            av_log(s, AV_LOG_ERROR, "HEVC bitstream malformed, no startcode found\n");
-            return AVERROR_PATCHWELCOME;
-        }
-        av_log(s, AV_LOG_WARNING, "HEVC bitstream error, startcode missing, size %d", pkt->size);
-        if (pkt->size)
-            av_log(s, AV_LOG_WARNING, " data %08"PRIX32, AV_RB32(pkt->data));
-        av_log(s, AV_LOG_WARNING, "\n");
-    }
     return 0;
 }
 
--- ffmpeg-build-static-sources/FFmpeg/libavformat/mux.c	2023-03-14 01:36:50.899247554 +0000
+++ ffmpeg-build-static-sources/FFmpeg/libavformat/mux.c	2023-05-04 12:32:01.676137059 +0000
@@ -536,24 +536,6 @@
         pkt->dts = sti->pts_buffer[0];
     }

-    if (sti->cur_dts && sti->cur_dts != AV_NOPTS_VALUE &&
-        ((!(s->oformat->flags & AVFMT_TS_NONSTRICT) &&
-          st->codecpar->codec_type != AVMEDIA_TYPE_SUBTITLE &&
-          st->codecpar->codec_type != AVMEDIA_TYPE_DATA &&
-          sti->cur_dts >= pkt->dts) || sti->cur_dts > pkt->dts)) {
-        av_log(s, AV_LOG_ERROR,
-               "Application provided invalid, non monotonically increasing dts to muxer in stream %d: %s >= %s\n",
-               st->index, av_ts2str(sti->cur_dts), av_ts2str(pkt->dts));
-        return AVERROR(EINVAL);
-    }
-    if (pkt->dts != AV_NOPTS_VALUE && pkt->pts != AV_NOPTS_VALUE && pkt->pts < pkt->dts) {
-        av_log(s, AV_LOG_ERROR,
-               "pts (%s) < dts (%s) in stream %d\n",
-               av_ts2str(pkt->pts), av_ts2str(pkt->dts),
-               st->index);
-        return AVERROR(EINVAL);
-    }
-
     if (s->debug & FF_FDEBUG_TS)
         av_log(s, AV_LOG_DEBUG, "av_write_frame: pts2:%s dts2:%s\n",
             av_ts2str(pkt->pts), av_ts2str(pkt->dts));
